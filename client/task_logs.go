package client

import (
	"context"
	"io"
	"net/url"
	"time"

	"github.com/moby/moby/client/internal/timestamp"
)

// TaskLogsOptions holds parameters to filter logs with.
type TaskLogsOptions struct {
	ShowStdout bool
	ShowStderr bool
	Since      string
	Until      string
	Timestamps bool
	Follow     bool
	Tail       string
	Details    bool
}

// TaskLogsResult holds the result of a task logs operation.
// It implements [io.ReadCloser].
type TaskLogsResult interface {
	io.ReadCloser
}

// TaskLogs returns the logs generated by a task.
// It's up to the caller to close the stream.
func (cli *Client) TaskLogs(ctx context.Context, taskID string, options TaskLogsOptions) (TaskLogsResult, error) {
	query := url.Values{}
	if options.ShowStdout {
		query.Set("stdout", "1")
	}

	if options.ShowStderr {
		query.Set("stderr", "1")
	}

	if options.Since != "" {
		ts, err := timestamp.GetTimestamp(options.Since, time.Now())
		if err != nil {
			return nil, err
		}
		query.Set("since", ts)
	}

	if options.Timestamps {
		query.Set("timestamps", "1")
	}

	if options.Details {
		query.Set("details", "1")
	}

	if options.Follow {
		query.Set("follow", "1")
	}
	query.Set("tail", options.Tail)

	resp, err := cli.get(ctx, "/tasks/"+taskID+"/logs", query, nil)
	if err != nil {
		return nil, err
	}
	return &taskLogsResult{
		body: resp.Body,
	}, nil
}

type taskLogsResult struct {
	// body must be closed to avoid a resource leak
	body io.ReadCloser
}

var (
	_ io.ReadCloser       = (*taskLogsResult)(nil)
	_ ContainerLogsResult = (*taskLogsResult)(nil)
)

func (r *taskLogsResult) Read(p []byte) (int, error) {
	if r == nil || r.body == nil {
		return 0, io.EOF
	}
	return r.body.Read(p)
}

func (r *taskLogsResult) Close() error {
	if r == nil || r.body == nil {
		return nil
	}
	return r.body.Close()
}
