// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/docker/docker/container/stream/streamv2/stdio/stdio.proto

package stdio

import (
	context "context"
	fmt "fmt"
	github_com_containerd_ttrpc "github.com/containerd/ttrpc"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type StreamFraming_FramingType int32

const (
	// No framing
	StreamFraming_NONE StreamFraming_FramingType = 0
	// Use framing from github.com/docker/docker/pkg/stdcopy
	StreamFraming_STDCOPY StreamFraming_FramingType = 1
	// Websocket with text framing
	StreamFraming_WEBSOCKET_TEXT StreamFraming_FramingType = 2
	// Websocket with binary framing
	StreamFraming_WEBSOCKET_BINARY StreamFraming_FramingType = 3
)

var StreamFraming_FramingType_name = map[int32]string{
	0: "NONE",
	1: "STDCOPY",
	2: "WEBSOCKET_TEXT",
	3: "WEBSOCKET_BINARY",
}

var StreamFraming_FramingType_value = map[string]int32{
	"NONE":             0,
	"STDCOPY":          1,
	"WEBSOCKET_TEXT":   2,
	"WEBSOCKET_BINARY": 3,
}

func (x StreamFraming_FramingType) String() string {
	return proto.EnumName(StreamFraming_FramingType_name, int32(x))
}

func (StreamFraming_FramingType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4c066d8b925c99ff, []int{2, 0}
}

// AttachStreamRequest is used to by the AttachStreams rpc to pass along references to file descriptors that the caller is requesting to attach with.
// Each file descriptor reference must be transferred to the stdio service before making this request.
// How the file descriptors are transferred to the stdio service is left up to the implementation to deal with.
//
// A nil descriptor means there is nothing to attach.
type AttachStreamsRequest struct {
	Process              string          `protobuf:"bytes,1,opt,name=process,proto3" json:"process,omitempty"`
	Stdin                *FileDescriptor `protobuf:"bytes,2,opt,name=stdin,proto3" json:"stdin,omitempty"`
	Stdout               *FileDescriptor `protobuf:"bytes,3,opt,name=stdout,proto3" json:"stdout,omitempty"`
	Stderr               *FileDescriptor `protobuf:"bytes,4,opt,name=stderr,proto3" json:"stderr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *AttachStreamsRequest) Reset()      { *m = AttachStreamsRequest{} }
func (*AttachStreamsRequest) ProtoMessage() {}
func (*AttachStreamsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4c066d8b925c99ff, []int{0}
}
func (m *AttachStreamsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttachStreamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttachStreamsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttachStreamsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachStreamsRequest.Merge(m, src)
}
func (m *AttachStreamsRequest) XXX_Size() int {
	return m.Size()
}
func (m *AttachStreamsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachStreamsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AttachStreamsRequest proto.InternalMessageInfo

// AttachStreamRequest is used to by the AttachStreamsMultiplexed rpc to pass along references to file descriptors that the caller is requesting to attach with.
// Each file descriptor reference must be transferred to the stdio service before making this request.
// How the file descriptors are transferred to the stdio service is left up to the implementation to deal with.
type AttachStreamsMultiplexedRequest struct {
	Process string `protobuf:"bytes,1,opt,name=process,proto3" json:"process,omitempty"`
	// Stream specifies the file descriptor that will be used for sending/receiving stdio with framing.
	// Stream must never be nil.
	Stream  *FileDescriptor `protobuf:"bytes,2,opt,name=stream,proto3" json:"stream,omitempty"`
	Framing StreamFraming   `protobuf:"bytes,3,opt,name=framing,proto3" json:"framing"`
	// include_stdout and include_stderr denote which streams are to be multiplexed on the output stream.
	// At lease one must be specified or an error will be generated.
	IncludeStdin         bool     `protobuf:"varint,4,opt,name=include_stdin,json=includeStdin,proto3" json:"include_stdin,omitempty"`
	IncludeStdout        bool     `protobuf:"varint,5,opt,name=include_stdout,json=includeStdout,proto3" json:"include_stdout,omitempty"`
	IncludeStderr        bool     `protobuf:"varint,6,opt,name=include_stderr,json=includeStderr,proto3" json:"include_stderr,omitempty"`
	DetachKeys           []byte   `protobuf:"bytes,7,opt,name=detach_keys,json=detachKeys,proto3" json:"detach_keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AttachStreamsMultiplexedRequest) Reset()      { *m = AttachStreamsMultiplexedRequest{} }
func (*AttachStreamsMultiplexedRequest) ProtoMessage() {}
func (*AttachStreamsMultiplexedRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4c066d8b925c99ff, []int{1}
}
func (m *AttachStreamsMultiplexedRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttachStreamsMultiplexedRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttachStreamsMultiplexedRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttachStreamsMultiplexedRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachStreamsMultiplexedRequest.Merge(m, src)
}
func (m *AttachStreamsMultiplexedRequest) XXX_Size() int {
	return m.Size()
}
func (m *AttachStreamsMultiplexedRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachStreamsMultiplexedRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AttachStreamsMultiplexedRequest proto.InternalMessageInfo

// StreamFraming defines how an stream should be framed
type StreamFraming struct {
	Type                 StreamFraming_FramingType `protobuf:"varint,1,opt,name=type,proto3,enum=docker.container.services.stdio.v1.StreamFraming_FramingType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *StreamFraming) Reset()      { *m = StreamFraming{} }
func (*StreamFraming) ProtoMessage() {}
func (*StreamFraming) Descriptor() ([]byte, []int) {
	return fileDescriptor_4c066d8b925c99ff, []int{2}
}
func (m *StreamFraming) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamFraming) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamFraming.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamFraming) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamFraming.Merge(m, src)
}
func (m *StreamFraming) XXX_Size() int {
	return m.Size()
}
func (m *StreamFraming) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamFraming.DiscardUnknown(m)
}

var xxx_messageInfo_StreamFraming proto.InternalMessageInfo

// FileDescriptor represents a reference to a file descriptor which should exist in the process of the stdio service.
//
// This will be used like so: `os.NewFile(desc.Fileno, desc.Name)`.
type FileDescriptor struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Fileno               uint32   `protobuf:"varint,2,opt,name=fileno,proto3" json:"fileno,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileDescriptor) Reset()      { *m = FileDescriptor{} }
func (*FileDescriptor) ProtoMessage() {}
func (*FileDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_4c066d8b925c99ff, []int{3}
}
func (m *FileDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileDescriptor.Merge(m, src)
}
func (m *FileDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *FileDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_FileDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_FileDescriptor proto.InternalMessageInfo

// OpenStreamsRequest defines the set of fifos to use for a new process to be managed by the stdio service
type OpenStreamsRequest struct {
	// process is a unique ID that the caller specifies that will be used in subseqent attach requests.
	Process              string   `protobuf:"bytes,1,opt,name=process,proto3" json:"process,omitempty"`
	Stdin                string   `protobuf:"bytes,2,opt,name=stdin,proto3" json:"stdin,omitempty"`
	Stdout               string   `protobuf:"bytes,3,opt,name=stdout,proto3" json:"stdout,omitempty"`
	Stderr               string   `protobuf:"bytes,4,opt,name=stderr,proto3" json:"stderr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OpenStreamsRequest) Reset()      { *m = OpenStreamsRequest{} }
func (*OpenStreamsRequest) ProtoMessage() {}
func (*OpenStreamsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4c066d8b925c99ff, []int{4}
}
func (m *OpenStreamsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenStreamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenStreamsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenStreamsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenStreamsRequest.Merge(m, src)
}
func (m *OpenStreamsRequest) XXX_Size() int {
	return m.Size()
}
func (m *OpenStreamsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenStreamsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OpenStreamsRequest proto.InternalMessageInfo

// CloseStreamsRequest describes the streams that should be cleaned up
type CloseStreamsRequest struct {
	Process              string   `protobuf:"bytes,1,opt,name=process,proto3" json:"process,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CloseStreamsRequest) Reset()      { *m = CloseStreamsRequest{} }
func (*CloseStreamsRequest) ProtoMessage() {}
func (*CloseStreamsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4c066d8b925c99ff, []int{5}
}
func (m *CloseStreamsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloseStreamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloseStreamsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloseStreamsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloseStreamsRequest.Merge(m, src)
}
func (m *CloseStreamsRequest) XXX_Size() int {
	return m.Size()
}
func (m *CloseStreamsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CloseStreamsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CloseStreamsRequest proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("docker.container.services.stdio.v1.StreamFraming_FramingType", StreamFraming_FramingType_name, StreamFraming_FramingType_value)
	proto.RegisterType((*AttachStreamsRequest)(nil), "docker.container.services.stdio.v1.AttachStreamsRequest")
	proto.RegisterType((*AttachStreamsMultiplexedRequest)(nil), "docker.container.services.stdio.v1.AttachStreamsMultiplexedRequest")
	proto.RegisterType((*StreamFraming)(nil), "docker.container.services.stdio.v1.StreamFraming")
	proto.RegisterType((*FileDescriptor)(nil), "docker.container.services.stdio.v1.FileDescriptor")
	proto.RegisterType((*OpenStreamsRequest)(nil), "docker.container.services.stdio.v1.OpenStreamsRequest")
	proto.RegisterType((*CloseStreamsRequest)(nil), "docker.container.services.stdio.v1.CloseStreamsRequest")
}

func init() {
	proto.RegisterFile("github.com/docker/docker/container/stream/streamv2/stdio/stdio.proto", fileDescriptor_4c066d8b925c99ff)
}

var fileDescriptor_4c066d8b925c99ff = []byte{
	// 660 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0xdf, 0x4e, 0x1a, 0x4f,
	0x14, 0x66, 0x11, 0x41, 0x0e, 0x42, 0xc8, 0xfc, 0x08, 0xd9, 0xf8, 0x4b, 0xd0, 0x6c, 0xd3, 0xc4,
	0xab, 0xdd, 0x48, 0x93, 0xd6, 0x34, 0xed, 0x85, 0x20, 0xa6, 0xad, 0x29, 0xd4, 0x85, 0xa4, 0xda,
	0xa4, 0x21, 0xb8, 0x7b, 0xc4, 0x8d, 0xcb, 0xce, 0x76, 0x66, 0x56, 0xcb, 0x5d, 0x9f, 0xa1, 0x8f,
	0xd2, 0xa7, 0xf0, 0xb2, 0x97, 0xbd, 0x6a, 0x2b, 0x0f, 0xd0, 0x67, 0x68, 0xf6, 0x0f, 0xca, 0x56,
	0x89, 0xab, 0xde, 0x30, 0x33, 0x27, 0xe7, 0x7c, 0x67, 0xf8, 0xbe, 0xf9, 0xce, 0xc2, 0xf6, 0xd0,
	0x12, 0xc7, 0xde, 0xa1, 0x6a, 0xd0, 0x91, 0x66, 0x52, 0xe3, 0x04, 0xd9, 0x74, 0x31, 0xa8, 0x23,
	0x06, 0x96, 0x83, 0x4c, 0xe3, 0x82, 0xe1, 0x60, 0x14, 0x2d, 0xa7, 0x75, 0x8d, 0x0b, 0xd3, 0xa2,
	0xe1, 0xaf, 0xea, 0x32, 0x2a, 0x28, 0x51, 0xc2, 0x1a, 0xf5, 0xb2, 0x46, 0xe5, 0xc8, 0x4e, 0x2d,
	0x03, 0xb9, 0x1a, 0xa6, 0x9d, 0x6e, 0xac, 0xfc, 0x3f, 0xa4, 0x74, 0x68, 0xa3, 0x16, 0x54, 0x1c,
	0x7a, 0x47, 0x1a, 0x8e, 0x5c, 0x31, 0x0e, 0x01, 0x56, 0x2a, 0x43, 0x3a, 0xa4, 0xc1, 0x56, 0xf3,
	0x77, 0x61, 0x54, 0xf9, 0x9a, 0x86, 0xca, 0x96, 0x10, 0x03, 0xe3, 0xb8, 0x1b, 0xf4, 0xe6, 0x3a,
	0x7e, 0xf2, 0x90, 0x0b, 0x22, 0x43, 0xce, 0x65, 0xd4, 0x40, 0xce, 0x65, 0x69, 0x4d, 0x5a, 0xcf,
	0xeb, 0xd3, 0x23, 0x79, 0x05, 0x8b, 0x7e, 0x47, 0x47, 0x4e, 0xaf, 0x49, 0xeb, 0x85, 0x7a, 0x5d,
	0xbd, 0xfd, 0x66, 0xea, 0x8e, 0x65, 0xe3, 0x36, 0x72, 0x83, 0x59, 0xae, 0xa0, 0x4c, 0x0f, 0x01,
	0xc8, 0x1b, 0xc8, 0x72, 0x61, 0x52, 0x4f, 0xc8, 0x0b, 0xf7, 0x86, 0x8a, 0x10, 0x22, 0x2c, 0x64,
	0x4c, 0xce, 0x3c, 0x08, 0x0b, 0x19, 0x53, 0xfe, 0xa4, 0x61, 0x35, 0x46, 0xca, 0x5b, 0xcf, 0x16,
	0x96, 0x6b, 0xe3, 0x67, 0x34, 0x6f, 0xe7, 0x27, 0xb8, 0x89, 0x5f, 0xf6, 0x00, 0x82, 0x22, 0x04,
	0xb2, 0x07, 0xb9, 0x23, 0x36, 0x18, 0x59, 0xce, 0x30, 0xa2, 0x68, 0x23, 0x09, 0x58, 0x78, 0xeb,
	0x9d, 0xb0, 0xb0, 0x91, 0x39, 0xff, 0xb9, 0x9a, 0xd2, 0xa7, 0x38, 0xe4, 0x11, 0x14, 0x2d, 0xc7,
	0xb0, 0x3d, 0x13, 0xfb, 0xa1, 0x8c, 0x3e, 0x5f, 0x4b, 0xfa, 0x72, 0x14, 0xec, 0x06, 0xca, 0x3c,
	0x86, 0xd2, 0x4c, 0x92, 0xaf, 0xd0, 0x62, 0x90, 0x55, 0xbc, 0xca, 0xf2, 0x49, 0x8f, 0xa7, 0xf9,
	0xe4, 0x67, 0xff, 0x4d, 0x43, 0xc6, 0xc8, 0x2a, 0x14, 0x4c, 0xf4, 0xe9, 0xec, 0x9f, 0xe0, 0x98,
	0xcb, 0xb9, 0x35, 0x69, 0x7d, 0x59, 0x87, 0x30, 0xb4, 0x8b, 0x63, 0xae, 0x7c, 0x93, 0xa0, 0x18,
	0xbb, 0x34, 0xd9, 0x83, 0x8c, 0x18, 0xbb, 0x18, 0x70, 0x5b, 0xaa, 0xbf, 0xbc, 0xf3, 0xbf, 0x56,
	0xa3, 0xb5, 0x37, 0x76, 0x51, 0x0f, 0xa0, 0x94, 0x36, 0x14, 0x66, 0x82, 0x64, 0x09, 0x32, 0xed,
	0x4e, 0xbb, 0x55, 0x4e, 0x91, 0x02, 0xe4, 0xba, 0xbd, 0xed, 0x66, 0xe7, 0xdd, 0x41, 0x59, 0x22,
	0x04, 0x4a, 0xef, 0x5b, 0x8d, 0x6e, 0xa7, 0xb9, 0xdb, 0xea, 0xf5, 0x7b, 0xad, 0xfd, 0x5e, 0x39,
	0x4d, 0x2a, 0x50, 0xbe, 0x8a, 0x35, 0x5e, 0xb7, 0xb7, 0xf4, 0x83, 0xf2, 0x82, 0xf2, 0x02, 0x4a,
	0x71, 0xd5, 0x08, 0x81, 0x8c, 0x33, 0x18, 0x61, 0xf4, 0x20, 0x82, 0x3d, 0xa9, 0x42, 0xf6, 0xc8,
	0xb2, 0xd1, 0xa1, 0xc1, 0x6b, 0x28, 0xea, 0xd1, 0x49, 0x11, 0x40, 0x3a, 0x2e, 0x3a, 0x89, 0x5d,
	0x57, 0x99, 0x75, 0x5d, 0x7e, 0xea, 0xa0, 0x6a, 0xcc, 0x41, 0xf9, 0x4b, 0x37, 0x54, 0x63, 0x6e,
	0xc8, 0x5f, 0xbe, 0x6c, 0x0d, 0xfe, 0x6b, 0xda, 0x94, 0x63, 0xd2, 0xb6, 0xf5, 0x5f, 0x0b, 0xb0,
	0xe8, 0x3f, 0x09, 0x4a, 0x06, 0x50, 0x8c, 0x79, 0x82, 0x6c, 0x26, 0x11, 0xe5, 0xa6, 0xd9, 0xb2,
	0x52, 0x55, 0xc3, 0x41, 0xa5, 0x4e, 0x07, 0x95, 0xda, 0xf2, 0x07, 0x15, 0x39, 0x03, 0x79, 0x9e,
	0xed, 0x48, 0xf3, 0xce, 0xdd, 0xae, 0x9b, 0x76, 0x6e, 0xe3, 0x8f, 0x50, 0x98, 0x11, 0x83, 0x3c,
	0x4d, 0xd2, 0xeb, 0xba, 0x7a, 0x73, 0xe1, 0xfb, 0xb0, 0x3c, 0xcb, 0x3a, 0x79, 0x96, 0x04, 0xff,
	0x06, 0x9d, 0xe6, 0x36, 0x78, 0x0e, 0x4b, 0xdd, 0x63, 0x4f, 0x98, 0xf4, 0xcc, 0x21, 0x73, 0x72,
	0xe6, 0xd5, 0x36, 0xf4, 0xf3, 0x8b, 0x5a, 0xea, 0xc7, 0x45, 0x2d, 0xf5, 0x65, 0x52, 0x93, 0xce,
	0x27, 0x35, 0xe9, 0xfb, 0xa4, 0x26, 0xfd, 0x9e, 0xd4, 0xa4, 0x0f, 0x9b, 0xf7, 0xfd, 0x70, 0xed,
	0x4b, 0x87, 0xd9, 0xa0, 0xcb, 0x93, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xd2, 0xcd, 0x52, 0x10,
	0xfd, 0x06, 0x00, 0x00,
}

func (m *AttachStreamsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttachStreamsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttachStreamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stderr != nil {
		{
			size, err := m.Stderr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStdio(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Stdout != nil {
		{
			size, err := m.Stdout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStdio(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Stdin != nil {
		{
			size, err := m.Stdin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStdio(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Process) > 0 {
		i -= len(m.Process)
		copy(dAtA[i:], m.Process)
		i = encodeVarintStdio(dAtA, i, uint64(len(m.Process)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AttachStreamsMultiplexedRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttachStreamsMultiplexedRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttachStreamsMultiplexedRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DetachKeys) > 0 {
		i -= len(m.DetachKeys)
		copy(dAtA[i:], m.DetachKeys)
		i = encodeVarintStdio(dAtA, i, uint64(len(m.DetachKeys)))
		i--
		dAtA[i] = 0x3a
	}
	if m.IncludeStderr {
		i--
		if m.IncludeStderr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.IncludeStdout {
		i--
		if m.IncludeStdout {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.IncludeStdin {
		i--
		if m.IncludeStdin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Framing.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStdio(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Stream != nil {
		{
			size, err := m.Stream.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStdio(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Process) > 0 {
		i -= len(m.Process)
		copy(dAtA[i:], m.Process)
		i = encodeVarintStdio(dAtA, i, uint64(len(m.Process)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StreamFraming) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamFraming) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamFraming) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintStdio(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Fileno != 0 {
		i = encodeVarintStdio(dAtA, i, uint64(m.Fileno))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintStdio(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OpenStreamsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenStreamsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenStreamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Stderr) > 0 {
		i -= len(m.Stderr)
		copy(dAtA[i:], m.Stderr)
		i = encodeVarintStdio(dAtA, i, uint64(len(m.Stderr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Stdout) > 0 {
		i -= len(m.Stdout)
		copy(dAtA[i:], m.Stdout)
		i = encodeVarintStdio(dAtA, i, uint64(len(m.Stdout)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Stdin) > 0 {
		i -= len(m.Stdin)
		copy(dAtA[i:], m.Stdin)
		i = encodeVarintStdio(dAtA, i, uint64(len(m.Stdin)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Process) > 0 {
		i -= len(m.Process)
		copy(dAtA[i:], m.Process)
		i = encodeVarintStdio(dAtA, i, uint64(len(m.Process)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloseStreamsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloseStreamsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloseStreamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Process) > 0 {
		i -= len(m.Process)
		copy(dAtA[i:], m.Process)
		i = encodeVarintStdio(dAtA, i, uint64(len(m.Process)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintStdio(dAtA []byte, offset int, v uint64) int {
	offset -= sovStdio(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AttachStreamsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Process)
	if l > 0 {
		n += 1 + l + sovStdio(uint64(l))
	}
	if m.Stdin != nil {
		l = m.Stdin.Size()
		n += 1 + l + sovStdio(uint64(l))
	}
	if m.Stdout != nil {
		l = m.Stdout.Size()
		n += 1 + l + sovStdio(uint64(l))
	}
	if m.Stderr != nil {
		l = m.Stderr.Size()
		n += 1 + l + sovStdio(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttachStreamsMultiplexedRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Process)
	if l > 0 {
		n += 1 + l + sovStdio(uint64(l))
	}
	if m.Stream != nil {
		l = m.Stream.Size()
		n += 1 + l + sovStdio(uint64(l))
	}
	l = m.Framing.Size()
	n += 1 + l + sovStdio(uint64(l))
	if m.IncludeStdin {
		n += 2
	}
	if m.IncludeStdout {
		n += 2
	}
	if m.IncludeStderr {
		n += 2
	}
	l = len(m.DetachKeys)
	if l > 0 {
		n += 1 + l + sovStdio(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamFraming) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovStdio(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStdio(uint64(l))
	}
	if m.Fileno != 0 {
		n += 1 + sovStdio(uint64(m.Fileno))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OpenStreamsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Process)
	if l > 0 {
		n += 1 + l + sovStdio(uint64(l))
	}
	l = len(m.Stdin)
	if l > 0 {
		n += 1 + l + sovStdio(uint64(l))
	}
	l = len(m.Stdout)
	if l > 0 {
		n += 1 + l + sovStdio(uint64(l))
	}
	l = len(m.Stderr)
	if l > 0 {
		n += 1 + l + sovStdio(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CloseStreamsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Process)
	if l > 0 {
		n += 1 + l + sovStdio(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovStdio(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStdio(x uint64) (n int) {
	return sovStdio(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AttachStreamsRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AttachStreamsRequest{`,
		`Process:` + fmt.Sprintf("%v", this.Process) + `,`,
		`Stdin:` + strings.Replace(this.Stdin.String(), "FileDescriptor", "FileDescriptor", 1) + `,`,
		`Stdout:` + strings.Replace(this.Stdout.String(), "FileDescriptor", "FileDescriptor", 1) + `,`,
		`Stderr:` + strings.Replace(this.Stderr.String(), "FileDescriptor", "FileDescriptor", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AttachStreamsMultiplexedRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AttachStreamsMultiplexedRequest{`,
		`Process:` + fmt.Sprintf("%v", this.Process) + `,`,
		`Stream:` + strings.Replace(this.Stream.String(), "FileDescriptor", "FileDescriptor", 1) + `,`,
		`Framing:` + strings.Replace(strings.Replace(this.Framing.String(), "StreamFraming", "StreamFraming", 1), `&`, ``, 1) + `,`,
		`IncludeStdin:` + fmt.Sprintf("%v", this.IncludeStdin) + `,`,
		`IncludeStdout:` + fmt.Sprintf("%v", this.IncludeStdout) + `,`,
		`IncludeStderr:` + fmt.Sprintf("%v", this.IncludeStderr) + `,`,
		`DetachKeys:` + fmt.Sprintf("%v", this.DetachKeys) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StreamFraming) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StreamFraming{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FileDescriptor) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FileDescriptor{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Fileno:` + fmt.Sprintf("%v", this.Fileno) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OpenStreamsRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OpenStreamsRequest{`,
		`Process:` + fmt.Sprintf("%v", this.Process) + `,`,
		`Stdin:` + fmt.Sprintf("%v", this.Stdin) + `,`,
		`Stdout:` + fmt.Sprintf("%v", this.Stdout) + `,`,
		`Stderr:` + fmt.Sprintf("%v", this.Stderr) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloseStreamsRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloseStreamsRequest{`,
		`Process:` + fmt.Sprintf("%v", this.Process) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringStdio(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}

type StdioService interface {
	AttachStreams(ctx context.Context, req *AttachStreamsRequest) (*types.Empty, error)
	AttachStreamsMultiplexed(ctx context.Context, req *AttachStreamsMultiplexedRequest) (*types.Empty, error)
	OpenStreams(ctx context.Context, req *OpenStreamsRequest) (*types.Empty, error)
	CloseStreams(ctx context.Context, req *CloseStreamsRequest) (*types.Empty, error)
	Shutdown(ctx context.Context, req *types.Empty) (*types.Empty, error)
}

func RegisterStdioService(srv *github_com_containerd_ttrpc.Server, svc StdioService) {
	srv.Register("docker.container.services.stdio.v1.Stdio", map[string]github_com_containerd_ttrpc.Method{
		"AttachStreams": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
			var req AttachStreamsRequest
			if err := unmarshal(&req); err != nil {
				return nil, err
			}
			return svc.AttachStreams(ctx, &req)
		},
		"AttachStreamsMultiplexed": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
			var req AttachStreamsMultiplexedRequest
			if err := unmarshal(&req); err != nil {
				return nil, err
			}
			return svc.AttachStreamsMultiplexed(ctx, &req)
		},
		"OpenStreams": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
			var req OpenStreamsRequest
			if err := unmarshal(&req); err != nil {
				return nil, err
			}
			return svc.OpenStreams(ctx, &req)
		},
		"CloseStreams": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
			var req CloseStreamsRequest
			if err := unmarshal(&req); err != nil {
				return nil, err
			}
			return svc.CloseStreams(ctx, &req)
		},
		"Shutdown": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
			var req types.Empty
			if err := unmarshal(&req); err != nil {
				return nil, err
			}
			return svc.Shutdown(ctx, &req)
		},
	})
}

type stdioClient struct {
	client *github_com_containerd_ttrpc.Client
}

func NewStdioClient(client *github_com_containerd_ttrpc.Client) StdioService {
	return &stdioClient{
		client: client,
	}
}

func (c *stdioClient) AttachStreams(ctx context.Context, req *AttachStreamsRequest) (*types.Empty, error) {
	var resp types.Empty
	if err := c.client.Call(ctx, "docker.container.services.stdio.v1.Stdio", "AttachStreams", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *stdioClient) AttachStreamsMultiplexed(ctx context.Context, req *AttachStreamsMultiplexedRequest) (*types.Empty, error) {
	var resp types.Empty
	if err := c.client.Call(ctx, "docker.container.services.stdio.v1.Stdio", "AttachStreamsMultiplexed", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *stdioClient) OpenStreams(ctx context.Context, req *OpenStreamsRequest) (*types.Empty, error) {
	var resp types.Empty
	if err := c.client.Call(ctx, "docker.container.services.stdio.v1.Stdio", "OpenStreams", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *stdioClient) CloseStreams(ctx context.Context, req *CloseStreamsRequest) (*types.Empty, error) {
	var resp types.Empty
	if err := c.client.Call(ctx, "docker.container.services.stdio.v1.Stdio", "CloseStreams", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *stdioClient) Shutdown(ctx context.Context, req *types.Empty) (*types.Empty, error) {
	var resp types.Empty
	if err := c.client.Call(ctx, "docker.container.services.stdio.v1.Stdio", "Shutdown", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}
func (m *AttachStreamsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStdio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttachStreamsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttachStreamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Process", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStdio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStdio
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStdio
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Process = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStdio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStdio
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStdio
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stdin == nil {
				m.Stdin = &FileDescriptor{}
			}
			if err := m.Stdin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStdio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStdio
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStdio
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stdout == nil {
				m.Stdout = &FileDescriptor{}
			}
			if err := m.Stdout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stderr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStdio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStdio
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStdio
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stderr == nil {
				m.Stderr = &FileDescriptor{}
			}
			if err := m.Stderr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStdio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStdio
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStdio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttachStreamsMultiplexedRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStdio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttachStreamsMultiplexedRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttachStreamsMultiplexedRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Process", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStdio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStdio
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStdio
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Process = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStdio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStdio
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStdio
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stream == nil {
				m.Stream = &FileDescriptor{}
			}
			if err := m.Stream.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Framing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStdio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStdio
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStdio
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Framing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeStdin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStdio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeStdin = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeStdout", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStdio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeStdout = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeStderr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStdio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeStderr = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetachKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStdio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStdio
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStdio
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DetachKeys = append(m.DetachKeys[:0], dAtA[iNdEx:postIndex]...)
			if m.DetachKeys == nil {
				m.DetachKeys = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStdio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStdio
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStdio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamFraming) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStdio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamFraming: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamFraming: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStdio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= StreamFraming_FramingType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStdio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStdio
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStdio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStdio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStdio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStdio
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStdio
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fileno", wireType)
			}
			m.Fileno = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStdio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fileno |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStdio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStdio
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStdio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenStreamsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStdio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenStreamsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenStreamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Process", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStdio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStdio
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStdio
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Process = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStdio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStdio
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStdio
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stdin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStdio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStdio
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStdio
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stdout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stderr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStdio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStdio
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStdio
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stderr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStdio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStdio
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStdio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloseStreamsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStdio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloseStreamsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloseStreamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Process", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStdio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStdio
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStdio
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Process = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStdio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStdio
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStdio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStdio(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStdio
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStdio
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStdio
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStdio
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStdio
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStdio
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStdio        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStdio          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStdio = fmt.Errorf("proto: unexpected end of group")
)
