#!/bin/bash
set -e

# This script creates the apt repos for the .deb files generated by hack/make/build-deb
#
# The following can then be used as apt sources:
# 	deb http://apt.dockerproject.org/repo $distro-$release $version
#
# For example:
#	deb http://apt.dockerproject.org/repo ubuntu-trusty main
#	deb http://apt.dockerproject.org/repo ubuntu-trusty testing
#	deb http://apt.dockerproject.org/repo debian-wheezy experimental
#	deb http://apt.dockerproject.org/repo debian-jessie main
#
# ... and so on and so forth for the builds created by hack/make/build-deb

source "$(dirname "$BASH_SOURCE")/.integration-daemon-start"
source "$(dirname "$BASH_SOURCE")/.detect-daemon-osarch"

: ${DOCKER_RELEASE_DIR:=$DEST}
: ${GPG_KEYID:=releasedocker}
APTDIR=$DOCKER_RELEASE_DIR/apt/repo

# setup the apt repo (if it does not exist)
mkdir -p "$APTDIR/conf" "$APTDIR/db"

# supported arches/sections
arches=( amd64 i386 )

# Preserve existing components but don't add any non-existing ones
for component in main testing experimental ; do
	if ls "$APTDIR/dists/*/$component" >/dev/null 2>&1 ; then
		components+=( $component )
	fi
done

# set the component for the version being released
component="main"

if [[ "$VERSION" == *-rc* ]]; then
	component="testing"
fi

if [ "$DOCKER_EXPERIMENTAL" ] || [[ "$VERSION" == *-dev ]] || [ -n "$(git status --porcelain)" ]; then
	component="experimental"
fi

# Make sure our component is in the list of components
if [[ ! "${components[*]}" =~ $component ]] ; then
	components+=( $component )
fi

# create apt-ftparchive file on every run. This is essential to avoid
# using stale versions of the config file that could cause unnecessary
# refreshing of bits for EOL-ed releases.
cat <<-EOF > "$APTDIR/conf/apt-ftparchive.conf"
Dir {
	ArchiveDir "${APTDIR}";
	CacheDir "${APTDIR}/db";
};

Default {
	Packages::Compress ". gzip bzip2";
	Sources::Compress ". gzip bzip2";
	Contents::Compress ". gzip bzip2";
};

TreeDefault {
	BinCacheDB "packages-\$(SECTION)-\$(ARCH).db";
	Directory "pool/\$(SECTION)";
	Packages "\$(DIST)/\$(SECTION)/binary-\$(ARCH)/Packages";
	SrcDirectory "pool/\$(SECTION)";
	Sources "\$(DIST)/\$(SECTION)/source/Sources";
	Contents "\$(DIST)/\$(SECTION)/Contents-\$(ARCH)";
	FileList "$APTDIR/\$(DIST)/\$(SECTION)/filelist";
};
EOF

for dir in contrib/builder/deb/${PACKAGE_ARCH}/*/; do
	version="$(basename "$dir")"
	suite="${version//debootstrap-}"

	cat <<-EOF
	Tree "dists/${suite}" {
		Sections "${components[*]}";
		Architectures "${arches[*]}";
	}

	EOF
done >> "$APTDIR/conf/apt-ftparchive.conf"

if [ ! -f "$APTDIR/conf/docker-engine-release.conf" ]; then
	cat <<-EOF > "$APTDIR/conf/docker-engine-release.conf"
	APT::FTPArchive::Release::Origin "Docker";
	APT::FTPArchive::Release::Components "${components[*]}";
	APT::FTPArchive::Release::Label "Docker APT Repository";
	APT::FTPArchive::Release::Architectures "${arches[*]}";
	EOF
fi

# release the debs
for dir in contrib/builder/deb/${PACKAGE_ARCH}/*/; do
	version="$(basename "$dir")"
	codename="${version//debootstrap-}"

	DEBFILE=( "bundles/$VERSION/build-deb/$version/docker-engine"*.deb )

	# if we have a $GPG_PASSPHRASE we may as well
	# dpkg-sign before copying the deb into the pool
	if [ ! -z "$GPG_PASSPHRASE" ]; then
		dpkg-sig -g "--no-tty --passphrase '$GPG_PASSPHRASE'" \
			-k "$GPG_KEYID" --sign builder "${DEBFILE[@]}"
	fi

	# add the deb for each component for the distro version into the pool
	mkdir -p "$APTDIR/pool/$component/d/docker-engine/"
	cp "${DEBFILE[@]}" "$APTDIR/pool/$component/d/docker-engine/"

	# update the filelist for this codename/component
	mkdir -p "$APTDIR/dists/$codename/$component"
	find "$APTDIR/pool/$component" \
		-name *~${codename#*-}*.deb > "$APTDIR/dists/$codename/$component/filelist"
done

# run the apt-ftparchive commands so we can have pinning
apt-ftparchive generate "$APTDIR/conf/apt-ftparchive.conf"

for dir in contrib/builder/deb/${PACKAGE_ARCH}/*/; do
	version="$(basename "$dir")"
	codename="${version//debootstrap-}"

	apt-ftparchive \
		-o "APT::FTPArchive::Release::Codename=$codename" \
		-o "APT::FTPArchive::Release::Suite=$codename" \
		-c "$APTDIR/conf/docker-engine-release.conf" \
		release \
		"$APTDIR/dists/$codename" > "$APTDIR/dists/$codename/Release"

	for arch in "${arches[@]}"; do
		mkdir -p "$APTDIR/dists/$codename/$component/binary-$arch"
		apt-ftparchive \
			-o "APT::FTPArchive::Release::Codename=$codename" \
			-o "APT::FTPArchive::Release::Suite=$codename" \
			-o "APT::FTPArchive::Release::Component=$component" \
			-o "APT::FTPArchive::Release::Architecture=$arch" \
			-c "$APTDIR/conf/docker-engine-release.conf" \
			release \
			"$APTDIR/dists/$codename/$component/binary-$arch" > "$APTDIR/dists/$codename/$component/binary-$arch/Release"
	done
done
